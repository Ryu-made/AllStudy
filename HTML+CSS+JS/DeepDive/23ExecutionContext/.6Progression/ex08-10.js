// .4 함수 코드 평가
// 함수 코드 평가에는 이러한 순서가 있다.
var x = 1;
const y = 2;

/* 1. foo 함수가 호출되면 우선 foo 함수 실행 컨텍스트 생성된다. 
 * 이 실행 컨텍스트는 함수 렉시컬 환경이 완성되고 나서,
 * 실행 컨텍스트 스택에 푸쉬되어 '실행 중인 컨텍스트'가 된다. 
 */
function foo(a) {
  /* 2. foo 함수 렉시컬 환경을 생성,
   * 이후 foo 함수 실행 컨텍스트에 바인딩한다.
   * 
   * 2-1. 함수 렉시컬 환경 구성 컴포넌트 중
   * 함수 환경 렉코드를 생성한다.
   * 함수 환경 레코드는 매개변수, arguments, 내부의 지역 변수, 중첩 함수 등을
   * 등록, 관리하는 공간이다.
   * 
   * 2-2. 함수 환경 레코드의 [[ThisValue]] 내부 슬롯에 this가 바인딩된다.
   * 이는 함수 호출 방식에 따라 바인딩되는 값(객체)이 다르다. 
   * 예를 들어 foo 함수는 일반 함수로 호출됐으므로 this는 전역 객체를 가리키고,
   * this가 바인딩된 곳인 [[ThisValue]] 내부 슬롯에는 전역 객체가 바인딩된다.
   * 그래서 foo 함수의 this를 호출하면 
   * 내부 슬롯에 바인딩된 전역 객체가 반환된다.
   * 
   * 2-3. 외부 렉시컬 환경에 대한 참조
   * 전역 코드에 정의된 함수는 전역 코드 평가 시점에 평가된다.
   * 그래서 전역 실행 컨텍스트에 따라 외부 렉시컬 환경에 대한 참조는 
   * 전역 렉시컬 환경에 참조가 할당된다.
   * 쉽게 얘기하면 foo 함수가 정의된 시점의 상위 스코프가 전역 스코프이므로
   * foo 함수 호출 시점에도 전역 환경의 참조를
   * 자신의 외부 참조로 사용한다는 뜻이다.
   * 외부 참조 스코프는 함수 객체의 내부 슬롯 [[Environment]]에 저장한다.
   * 이곳에 저장된 렉시컬 스코프의 구현 매커니즘은 
   * '클로저'를 이해할 수 있는 중요 단서이다.
   */

  // .5 함수 코드 실행
  /* 런타임이 시작되면 지역 변수인 x, y에 값이 할당되고,
   * 중첩 함수인 bar 함수가 호출된다.
   * 참고로 식별자 x, y는 foo 함수 렉시컬 환경에서 모두 검색되므로
   * 해당 식별자에 값을 바인딩한다. (식별자가 없다면 전역 렉시컬 환경에서 검색한다.)
   */

  var x = 3;
  const y = 4;
  // .6 bar 함수 코드 평가
  /* bar 함수 내부로 코드 제어권이 이동하며
   * 실행 컨텍스트와 렉시컬 환경의 생성 과정은 foo 함수와 동일하다.
   * 다만 외부 렉시컬 환경 참조는 함수가 정의된 상위 스코프가 다르므로
   * [[Environment]] 내부 슬롯에 전역 환경 참조가 아닌 
   * foo 함수의 환경 참조가 바인딩된다.
   */
  function bar(b) {
    // .7 bar 함수 코드 실행
    /* bar 함수 런타임시에는 소스코드가 순차적으로 실행된다.
     * 매개변수에 인수를 할당, 변수 할당문으로 지역 변수 z에 값을 할당한다.
     */
    const z = 5;
    /* 이후 실행되는 console.log 메소드
     * 1. console 식별자 검색
     * console 식별자를 검색할 때는 항상 
     * 실행 컨텍스트의 렉시컬 환경에서 검색을 시작한다.
     * 현재 bar 함수 실행 컨텍스트의 렉시컬 환경에는 console이 없으므로
     * 상위 스코프인 foo 함수 렉시컬 환경에서 검색하고,
     * 이곳에도 없으므로 외부 렉시컬 환경 참조가 가리키는 
     * 전역 렉시컬 환경에서 console 식별자를 찾는다. 
     * 객체 환경 레코드의 BindingObject를 통해 
     * 전역 객체에서 console 식별자를 찾을 수 있다.
     * 
     * 2. log 메소드 검색
     * console.log 메소드는 console 객체가 직접 소유하는 메소드이므로
     * 프로토타입 체인을 거치지 않고 바로 찾게 된다.
     * 
     * 3. 표현식 a + b + x + y + z
     * 표현식 평가를 위해 식별자 a부터 순차적으로 검색한다.
     * 인수 a, 지역변수 x와 y는 foo 함수 렉시컬 환경에서,
     * 인수 b, 지역변수 z는 bar 함수 렉시컬 환경에서 검색된다.
     * 이제 a + b + x + y + z가 평가되어 생성한 값을 메소드에 전달한다.
     * log 메소드를 통해 콘솔에 값을 출력하고 나면 메소드가 종료된다.
     */
    console.log(a + b + x + y + z);
  }
  bar(10); // ← bar 함수 호출 직전 시점
}

foo(20); // ← foo 함수 호출 직전 시점

// .8 함수 코드 실행 종료
/* 
bar 함수가 종료되는 시점에 실행 컨텍스트 스택에서 bar 함수 실행 컨텍스트가 제거된다.
그리고 foo 함수가 현재 실행 컨텍스트가 되면
bar 함수 렉시컬 환경을 참조하는 객체를 확인하고 더 이상 참조하지 않는다면
가비지 컬렉터가 할당되었던 메모리 공간을 지우고 소멸된다.
bar 함수 렉시컬 환경은 함수 실행 컨텍스트와 독립된 객체인 것만 기억하자.

foo 함수에 더 이상 실행할 코드가 없을 때 foo 함수의 실행 컨텍스트가 팝되고
전역 실행 컨텍스트가 현재 실행 중인 컨텍스트로 바뀐다.
그럼 전역에도 더 이상 실행할 코드가 없으므로 
마찬가지로 실행 컨텍스트 스택에서 팝되고 실행 코드가 아무것도 없는 상태가 된다.
*/
