// *다음은 원시 타입이 래퍼 객체로 임시 변환되고 다시 원래 타입으로 돌아오는 과정을 나타내는 예시이다.

// [1] 식별자 str은 문자열을 값으로 가지고 있다.
const str = 'hello';

// [2] 식별자 str은 암묵적으로 생성된 래퍼 객체를 가리킨다.
// 식별자 str의 값  'hello'는 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된다.
// 래퍼 객체에 name 프로퍼티가 동적 추가된다.
str.name = 'Park';

// [3] 식별자 str은 다시 원래의 문자열, 즉 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시 값을 갖는다.
// 이때 [2]에서 생성된 래퍼 객체는 아무도 참조하지 않는 상태이므로 가비지 컬렉션의 대상이 된다. (함께 추가된 프로퍼티도 모두 제거된다.)

// [4] 식별자 str은 새롭게 암묵적으로 생성된([2]에서 생성된 래퍼 객체와는 다른) 래퍼 객체를 가리킨다.
// 새롭게 생성된 래퍼 객체에는 name 프로퍼티가 존재하지 않는다.
console.log(str.name); // undefined
// [5] 식별자 str은 다시 원래의 문자열, 즉 래퍼 객체의 [[StringData]] 내부 슬롯에 할당된 원시값을 가진다.
// 이때 [4]에서 생성된 래퍼 객체는 아무도 참조하지 않는 상태이므로 역시 가비지 컬렉션의 대상이 된다.
console.log(typeof str, str); // string 'hello'

// Number 생성자 함수의 래퍼 객체로 변환되는 숫자 값도 마찬가지이다.
// 숫자 값은 래퍼 객체의 [[StringData]] 대신에 [[NumberData]] 내부 슬롯에 할당되는 차이가 있을 뿐이다.
const num = 1.25;

// 원시 타입인 숫자가 래퍼 객체인 Number 객체로 변환된다.
console.log(num.toFixed()); // 1

// 래퍼 객체로 프로퍼티나 메소드를 호출(접근)한 후, 다시 원시값으로 되돌린다.
console.log(typeof num, num); // number 1.5

// ES6 부터 도입된 Symbol 값도 원시값이며 래퍼 객체를 생성할 수 있다.
// 다만 기본 원시값과 달리 리터럴 표기법으로 생성할 수 없다는 차이점이 존재한다.
// 마지막으로 null 값과 undefined는 래퍼 객체를 생성할 수 없다. (생성자 함수가 없다.) 그래서 객체처럼 프로퍼티나 함수를 호출하려고 하면 에러가 발생한다.